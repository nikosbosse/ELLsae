% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ELLsae_base.R
\name{ellsae}
\alias{ellsae}
\title{ellsae}
\usage{
ellsae(model, survey, census, location_survey, n_boot = 250L, seed,
  welfare.function, transfy, transfy_inv, output = "default",
  cores = "auto", quantiles = c(0, 0.25, 0.5, 0.75, 1), clustermeans,
  location_census, save_boot = F)
}
\arguments{
\item{model}{a model that describes the relationship betwenn the response and
the explanatory variables. Input must be a linear model that can be
processed by \code{lm()}}

\item{survey}{data set with the response variable of interest included.
Will be used to estimate the linear model}

\item{census}{dataset where the variable of interest is missing and shall
be imputed}

\item{location_survey}{string with the name of the variable in the survey data
set that contains information about the cluster (= location) of an
observation}

\item{n_boot}{integer with size of bootstrap sample}

\item{seed}{integer, seed can be set to obtain reproducible results}

\item{welfare.function}{function that transforms the bootstraped variable of
interested to obtain some welfare estimate}

\item{transfy}{function to transform the response y in the model}

\item{transfy_inv}{inverse function of \code{transfy} for backtransformation}

\item{output}{character string or character vector. Either "default", "all",
or a vector with one or more of the following elements: c("summary",
"yboot", "model_fit", "bootsample", "survey", "census")}

\item{cores}{either a string, "auto", or an integer value indicating the
number of cores to be used for the estimation.}

\item{quantiles}{vector of requested quantiles for the \code{summaryboot}
output as decimals between 0 and 1.}

\item{clustermeans}{character vector with names of variables present in both
data sets. The mean of those variables in the census will be computed by
location and added to the survey data set before estimation of the linear
model. This may enhance precision of your estimates}

\item{location_census}{string with the name of the variable in the survey data
set that contains information about the cluster (= location) of an
observation. Only needed if \code{clustermeans} shall be computed.}

\item{save_boot}{logical value. TRUE saves the bootstrap sample as
BootstrapSampleELLsae-DATE.csv in your current working direktory.}
}
\value{
\code{ellsae} returns a list. By default, this list included a matrix
with basic summary statistics as specified in \code{quantiles}, a vector with
the means of the bootstrap samples for every observation, and the
\code{lm}-object obtained from the linear model estimation. In addition, the
user can request the full matrix of bootstrap samples, and an updated
data.table of the survey and census data set with residuals and location
effects and clustermeans added.
}
\description{
The function \code{ellsae} implements the "ELL-method" method for
 small area estimation by Elbers, C., Lanjouw, J. O. and Lanjouw, P (2003)
 used to impute a missing variable from a smaller survey dataset into a
 census. The imputation is based on a linear model and bootstrap samples
}
\details{
The function takes the the surveydata and uses the argument
\code{model} to estimate a linear model of the type \code{lm()}. In case the
argument \code{clustermeans} is specified, means from the census data for the
given variables are calculated and merged with the survey data by cluster
locations. These new explanatory variables are also used for the estimation of
the linear model. Rows with NA's are omitted from the computation.

The user may choose to transform the response variable using
a function, \code{transfy} previously to estimating the model. This function
will be directly applied to the entire vector of the response variable, i.e.
\code{transfy(response)}. This means your function needs to be able to take a
vector as input. For transformations like \code{log}, \code{exp}, \code{sqrt}
this will just give you an element-wise transformation. For more complex
transformation, you may want to use \code{\link{sapply}} inside your function,
to ensure element-wise transformation. This also applies to
\code{transfy_inv}, and \code{welfare.function} which need to be able to take
a matrix as input. In many cases a transformation like \code{transfy} could
also be achieved by altering the specified model appropriately, but using
\code{transfy} and \code{transfy_inv} is the recommended usage.


From the regression, location
effects are calculated as the mean by location of the regression residuals.
Individual random error terms are then obtained as the difference between the
regression residuals and the location effects. The bootstrapped response
variables are generated using three sources of randomness. The betas obtained
from \code{lm()} are replaced by draws from a multivariate normal
distribution. In addition random location effects and residuals are drawn with
replacement. Internally the sample is a matrix, \code{bootstrap}, with
the rows corresponding to bootstrap samples for one individual observation in
the census data set. 

If \code{transfy_inv} was specified, the bootstrap sample
is transformed back. This function will be directly applied to the matrix
of bootstrap samples, i.e. \code{transfy_inv(bootstrap)}. 

If a welfare
function was specified it will be used to transform the bootstrap sample. It
will be diretly applied to the matrix of bootstrap samples, i.e.
\code{welfare.function(bootstrap)}. Bootstrap samples that belong to one 
observation are arranged row-wise. 

\code{cores} specifies the number of cores to use for the calculation. As
parallelization is done in C++ and incurs little overhead this should in most
cases be left to "auto".

To obtain reproducicble results, seed must be specified. Simply running
\code{set.seed()} in R does not work. Providing a seed will not permanently
alter the seed in R.
}
\examples{
# Generate a sample survey and census data from the provided brazil data set
brazil <-  ELLsae::brazil
helper <- sample(x = 1:nrow(brazil), size = nrow(brazil)/5, replace = F)
helper <- sort(helper)
survey <- brazil[helper,]
census <- brazil[-helper,]
model.example <- hh_inc ~ geo2_br + age + sex + computer + trash

ELLsae::ellsae(model = model.example,
               survey = survey,
               census = census,
               location_survey = "geo2_br",
               n_boot = 250L,
               seed = 1234,
               transfy = log,
               transfy_inv = exp,
               output = "all",
               cores = "auto",
               quantiles = c(0, 0.25, 0.5, 0.75, 1),
               clustermeans = "age",
               location_census = "geo2_br",
               save_boot = FALSE)
}
\references{
Elbers, C., Lanjouw, J. O. and Lanjouw, P. (2003).
\emph{Micro-Level Estimation of Poverty and Inequality}. In: Econometrica
71.1, pp. 355-364, Jan 2003

Guadarrama Sanz, M., Molina, I., and Rao, J.N.K.  (2016). \emph{A comparison
of small area estimation methods for poverty mapping}. In: 17 (Mar. 2016),
41-66 and 156 and 158.
}
\seealso{
Other small area estimation methods can also be found in the package
 \code{sae}.
}
\keyword{SAE,}
\keyword{imputation}
